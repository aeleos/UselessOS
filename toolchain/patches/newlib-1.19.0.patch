diff -rupN _source/newlib-1.19.0/config.sub newlib-1.19.0/config.sub
--- _source/newlib-1.19.0/config.sub	2010-06-01 12:53:40.000000000 -0500
+++ newlib-1.19.0/config.sub	2011-04-24 20:37:12.000000000 -0500
@@ -1298,6 +1298,7 @@ case $os in
 	      | -sym* | -kopensolaris* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* | -aros* \
+	      | -toaru* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
diff -rupN _source/newlib-1.19.0/newlib/configure.host newlib-1.19.0/newlib/configure.host
--- _source/newlib-1.19.0/newlib/configure.host	2010-12-02 13:30:46.000000000 -0600
+++ newlib-1.19.0/newlib/configure.host	2011-04-24 20:38:10.000000000 -0500
@@ -418,6 +418,9 @@ case "${host}" in
   h8500-*-elf*)
 	sys_dir=h8500hms
 	;;
+  i[34567]86-*-toaru*)
+	sys_dir=toaru
+	;;
   i[34567]86-*-rdos*)
 	sys_dir=rdos
 	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
diff -rupN _source/newlib-1.19.0/newlib/libc/include/sys/stat.h newlib-1.19.0/newlib/libc/include/sys/stat.h
--- _source/newlib-1.19.0/newlib/libc/include/sys/stat.h	2010-08-06 13:26:21.000000000 -0500
+++ newlib-1.19.0/newlib/libc/include/sys/stat.h	2012-04-23 16:00:11.000000000 -0500
@@ -150,8 +150,8 @@ int	_EXFUN(mkfifo,( const char *__path,
 int	_EXFUN(stat,( const char *__path, struct stat *__sbuf ));
 mode_t	_EXFUN(umask,( mode_t __mask ));
 
-#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	_EXFUN(lstat,( const char *__path, struct stat *__buf ));
+#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	_EXFUN(mknod,( const char *__path, mode_t __mode, dev_t __dev ));
 #endif
 
diff -rupN _source/newlib-1.19.0/newlib/libc/include/sys/utime.h newlib-1.19.0/newlib/libc/include/sys/utime.h
--- _source/newlib-1.19.0/newlib/libc/include/sys/utime.h	2000-02-17 13:39:46.000000000 -0600
+++ newlib-1.19.0/newlib/libc/include/sys/utime.h	2012-04-23 16:01:17.000000000 -0500
@@ -15,6 +15,8 @@ struct utimbuf
   time_t modtime; 
 };
 
+int utime(const char *filename, const struct utimbuf *times);
+
 #ifdef __cplusplus
 };
 #endif
diff -rupN _source/newlib-1.19.0/newlib/libc/stdio/fseek.c newlib-1.19.0/newlib/libc/stdio/fseek.c
--- _source/newlib-1.19.0/newlib/libc/stdio/fseek.c	2009-12-17 13:43:43.000000000 -0600
+++ newlib-1.19.0/newlib/libc/stdio/fseek.c	2011-04-29 19:33:10.000000000 -0500
@@ -160,210 +160,6 @@ _DEFUN(_fseek_r, (ptr, fp, offset, whenc
       return EOF;
     }
 
-  /*
-   * Change any SEEK_CUR to SEEK_SET, and check `whence' argument.
-   * After this, whence is either SEEK_SET or SEEK_END.
-   */
-
-  switch (whence)
-    {
-    case SEEK_CUR:
-      /*
-       * In order to seek relative to the current stream offset,
-       * we have to first find the current stream offset a la
-       * ftell (see ftell for details).
-       */
-      _fflush_r (ptr, fp);   /* may adjust seek offset on append stream */
-      if (fp->_flags & __SOFF)
-	curoff = fp->_offset;
-      else
-	{
-	  curoff = seekfn (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
-	  if (curoff == -1L)
-	    {
-	      _funlockfile (fp);
-	      __sfp_lock_release ();
-	      return EOF;
-	    }
-	}
-      if (fp->_flags & __SRD)
-	{
-	  curoff -= fp->_r;
-	  if (HASUB (fp))
-	    curoff -= fp->_ur;
-	}
-      else if (fp->_flags & __SWR && fp->_p != NULL)
-	curoff += fp->_p - fp->_bf._base;
-
-      offset += curoff;
-      whence = SEEK_SET;
-      havepos = 1;
-      break;
-
-    case SEEK_SET:
-    case SEEK_END:
-      havepos = 0;
-      break;
-
-    default:
-      ptr->_errno = EINVAL;
-      _funlockfile (fp);
-      __sfp_lock_release ();
-      return (EOF);
-    }
-
-  /*
-   * Can only optimise if:
-   *	reading (and not reading-and-writing);
-   *	not unbuffered; and
-   *	this is a `regular' Unix file (and hence seekfn==__sseek).
-   * We must check __NBF first, because it is possible to have __NBF
-   * and __SOPT both set.
-   */
-
-  if (fp->_bf._base == NULL)
-    __smakebuf_r (ptr, fp);
-  if (fp->_flags & (__SWR | __SRW | __SNBF | __SNPT))
-    goto dumb;
-  if ((fp->_flags & __SOPT) == 0)
-    {
-      if (seekfn != __sseek
-	  || fp->_file < 0
-#ifdef __USE_INTERNAL_STAT64
-	  || _fstat64_r (ptr, fp->_file, &st)
-#else
-	  || _fstat_r (ptr, fp->_file, &st)
-#endif
-	  || (st.st_mode & S_IFMT) != S_IFREG)
-	{
-	  fp->_flags |= __SNPT;
-	  goto dumb;
-	}
-#ifdef	HAVE_BLKSIZE
-      fp->_blksize = st.st_blksize;
-#else
-      fp->_blksize = 1024;
-#endif
-      fp->_flags |= __SOPT;
-    }
-
-  /*
-   * We are reading; we can try to optimise.
-   * Figure out where we are going and where we are now.
-   */
-
-  if (whence == SEEK_SET)
-    target = offset;
-  else
-    {
-#ifdef __USE_INTERNAL_STAT64
-      if (_fstat64_r (ptr, fp->_file, &st))
-#else
-      if (_fstat_r (ptr, fp->_file, &st))
-#endif
-	goto dumb;
-      target = st.st_size + offset;
-    }
-  if ((long)target != target)
-    {
-      ptr->_errno = EOVERFLOW;
-      _funlockfile (fp);
-      __sfp_lock_release ();
-      return EOF;
-    }
-
-  if (!havepos)
-    {
-      if (fp->_flags & __SOFF)
-	curoff = fp->_offset;
-      else
-	{
-	  curoff = seekfn (ptr, fp->_cookie, 0L, SEEK_CUR);
-	  if (curoff == POS_ERR)
-	    goto dumb;
-	}
-      curoff -= fp->_r;
-      if (HASUB (fp))
-	curoff -= fp->_ur;
-    }
-
-  /*
-   * Compute the number of bytes in the input buffer (pretending
-   * that any ungetc() input has been discarded).  Adjust current
-   * offset backwards by this count so that it represents the
-   * file offset for the first byte in the current input buffer.
-   */
-
-  if (HASUB (fp))
-    {
-      curoff += fp->_r;       /* kill off ungetc */
-      n = fp->_up - fp->_bf._base;
-      curoff -= n;
-      n += fp->_ur;
-    }
-  else
-    {
-      n = fp->_p - fp->_bf._base;
-      curoff -= n;
-      n += fp->_r;
-    }
-
-  /*
-   * If the target offset is within the current buffer,
-   * simply adjust the pointers, clear EOF, undo ungetc(),
-   * and return.
-   */
-
-  if (target >= curoff && target < curoff + n)
-    {
-      register int o = target - curoff;
-
-      fp->_p = fp->_bf._base + o;
-      fp->_r = n - o;
-      if (HASUB (fp))
-	FREEUB (ptr, fp);
-      fp->_flags &= ~__SEOF;
-      memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
-      _funlockfile (fp);
-      __sfp_lock_release ();
-      return 0;
-    }
-
-  /*
-   * The place we want to get to is not within the current buffer,
-   * but we can still be kind to the kernel copyout mechanism.
-   * By aligning the file offset to a block boundary, we can let
-   * the kernel use the VM hardware to map pages instead of
-   * copying bytes laboriously.  Using a block boundary also
-   * ensures that we only read one block, rather than two.
-   */
-
-  curoff = target & ~(fp->_blksize - 1);
-  if (seekfn (ptr, fp->_cookie, curoff, SEEK_SET) == POS_ERR)
-    goto dumb;
-  fp->_r = 0;
-  fp->_p = fp->_bf._base;
-  if (HASUB (fp))
-    FREEUB (ptr, fp);
-  fp->_flags &= ~__SEOF;
-  n = target - curoff;
-  if (n)
-    {
-      if (__srefill_r (ptr, fp) || fp->_r < n)
-	goto dumb;
-      fp->_p += n;
-      fp->_r -= n;
-    }
-  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
-  _funlockfile (fp);
-  __sfp_lock_release ();
-  return 0;
-
-  /*
-   * We get here if we cannot optimise the seek ... just
-   * do it.  Allow the seek function to change fp->_bf._base.
-   */
-
 dumb:
   if (_fflush_r (ptr, fp)
       || seekfn (ptr, fp->_cookie, offset, whence) == POS_ERR)
diff -rupN _source/newlib-1.19.0/newlib/libc/stdlib/calloc.c newlib-1.19.0/newlib/libc/stdlib/calloc.c
--- _source/newlib-1.19.0/newlib/libc/stdlib/calloc.c	2008-10-31 16:08:03.000000000 -0500
+++ newlib-1.19.0/newlib/libc/stdlib/calloc.c	2012-04-23 15:45:46.000000000 -0500
@@ -57,6 +57,7 @@ Supporting OS subroutines required: <<cl
 
 #ifndef _REENT_ONLY
 
+#if 0
 _PTR
 _DEFUN (calloc, (n, size),
 	size_t n _AND
@@ -64,6 +65,7 @@ _DEFUN (calloc, (n, size),
 {
   return _calloc_r (_REENT, n, size);
 }
+#endif
 
 #endif
 #endif /* MALLOC_PROVIDED */
diff -rupN _source/newlib-1.19.0/newlib/libc/stdlib/malloc.c newlib-1.19.0/newlib/libc/stdlib/malloc.c
--- _source/newlib-1.19.0/newlib/libc/stdlib/malloc.c	2008-11-19 14:55:52.000000000 -0600
+++ newlib-1.19.0/newlib/libc/stdlib/malloc.c	2012-04-24 16:52:45.000000000 -0500
@@ -1,227 +1,955 @@
-/* VxWorks provides its own version of malloc, and we can't use this
-   one because VxWorks does not provide sbrk.  So we have a hook to
-   not compile this code.  */
-
-/* The routines here are simple cover fns to the routines that do the real
-   work (the reentrant versions).  */
-/* FIXME: Does the warning below (see WARNINGS) about non-reentrancy still
-   apply?  A first guess would be "no", but how about reentrancy in the *same*
-   thread?  */
-
-#ifdef MALLOC_PROVIDED
-
-int _dummy_malloc = 1;
-
-#else
-
-/*
-FUNCTION
-<<malloc>>, <<realloc>>, <<free>>---manage memory
-
-INDEX
-	malloc
-INDEX
-	realloc
-INDEX
-	reallocf
-INDEX
-	free
-INDEX
-	memalign
-INDEX
-	malloc_usable_size
-INDEX
-	_malloc_r
-INDEX
-	_realloc_r
-INDEX
-	_reallocf_r
-INDEX
-	_free_r
-INDEX
-	_memalign_r
-INDEX
-	_malloc_usable_size_r
-
-ANSI_SYNOPSIS
-	#include <stdlib.h>
-	void *malloc(size_t <[nbytes]>);
-	void *realloc(void *<[aptr]>, size_t <[nbytes]>);
-	void *reallocf(void *<[aptr]>, size_t <[nbytes]>);
-	void free(void *<[aptr]>);
-
-	void *memalign(size_t <[align]>, size_t <[nbytes]>);
-
-	size_t malloc_usable_size(void *<[aptr]>);
-
-	void *_malloc_r(void *<[reent]>, size_t <[nbytes]>);
-	void *_realloc_r(void *<[reent]>, 
-                         void *<[aptr]>, size_t <[nbytes]>);
-	void *_reallocf_r(void *<[reent]>, 
-                         void *<[aptr]>, size_t <[nbytes]>);
-	void _free_r(void *<[reent]>, void *<[aptr]>);
-
-	void *_memalign_r(void *<[reent]>,
-			  size_t <[align]>, size_t <[nbytes]>);
-
-	size_t _malloc_usable_size_r(void *<[reent]>, void *<[aptr]>);
-
-TRAD_SYNOPSIS
-	#include <stdlib.h>
-	char *malloc(<[nbytes]>)
-	size_t <[nbytes]>;
-
-	char *realloc(<[aptr]>, <[nbytes]>)
-	char *<[aptr]>;
-	size_t <[nbytes]>;
-
-	char *reallocf(<[aptr]>, <[nbytes]>)
-	char *<[aptr]>;
-	size_t <[nbytes]>;
-
-	void free(<[aptr]>)
-	char *<[aptr]>;
-
-	char *memalign(<[align]>, <[nbytes]>)
-	size_t <[align]>;
-	size_t <[nbytes]>;
-
-	size_t malloc_usable_size(<[aptr]>)
-	char *<[aptr]>;
-
-	char *_malloc_r(<[reent]>,<[nbytes]>)
-	char *<[reent]>;
-	size_t <[nbytes]>;
-
-	char *_realloc_r(<[reent]>, <[aptr]>, <[nbytes]>)
-	char *<[reent]>;
-	char *<[aptr]>;
-	size_t <[nbytes]>;
-
-	char *_reallocf_r(<[reent]>, <[aptr]>, <[nbytes]>)
-	char *<[reent]>;
-	char *<[aptr]>;
-	size_t <[nbytes]>;
-
-	void _free_r(<[reent]>, <[aptr]>)
-	char *<[reent]>;
-	char *<[aptr]>;
-
-	char *_memalign_r(<[reent]>, <[align]>, <[nbytes]>)
-	char *<[reent]>;
-	size_t <[align]>;
-	size_t <[nbytes]>;
-
-	size_t malloc_usable_size(<[reent]>, <[aptr]>)
-	char *<[reent]>;
-	char *<[aptr]>;
-
-DESCRIPTION
-These functions manage a pool of system memory.
-
-Use <<malloc>> to request allocation of an object with at least
-<[nbytes]> bytes of storage available.  If the space is available,
-<<malloc>> returns a pointer to a newly allocated block as its result.
-
-If you already have a block of storage allocated by <<malloc>>, but
-you no longer need all the space allocated to it, you can make it
-smaller by calling <<realloc>> with both the object pointer and the
-new desired size as arguments.  <<realloc>> guarantees that the
-contents of the smaller object match the beginning of the original object.
-
-Similarly, if you need more space for an object, use <<realloc>> to
-request the larger size; again, <<realloc>> guarantees that the
-beginning of the new, larger object matches the contents of the
-original object.
-
-When you no longer need an object originally allocated by <<malloc>>
-or <<realloc>> (or the related function <<calloc>>), return it to the
-memory storage pool by calling <<free>> with the address of the object
-as the argument.  You can also use <<realloc>> for this purpose by
-calling it with <<0>> as the <[nbytes]> argument.
-
-The <<reallocf>> function behaves just like <<realloc>> except if the
-function is required to allocate new storage and this fails.  In this
-case <<reallocf>> will free the original object passed in whereas
-<<realloc>> will not.
-
-The <<memalign>> function returns a block of size <[nbytes]> aligned
-to a <[align]> boundary.  The <[align]> argument must be a power of
-two.
-
-The <<malloc_usable_size>> function takes a pointer to a block
-allocated by <<malloc>>.  It returns the amount of space that is
-available in the block.  This may or may not be more than the size
-requested from <<malloc>>, due to alignment or minimum size
-constraints.
-
-The alternate functions <<_malloc_r>>, <<_realloc_r>>, <<_reallocf_r>>, 
-<<_free_r>>, <<_memalign_r>>, and <<_malloc_usable_size_r>> are reentrant
-versions.  The extra argument <[reent]> is a pointer to a reentrancy structure.
-
-If you have multiple threads of execution which may call any of these
-routines, or if any of these routines may be called reentrantly, then
-you must provide implementations of the <<__malloc_lock>> and
-<<__malloc_unlock>> functions for your system.  See the documentation
-for those functions.
-
-These functions operate by calling the function <<_sbrk_r>> or
-<<sbrk>>, which allocates space.  You may need to provide one of these
-functions for your system.  <<_sbrk_r>> is called with a positive
-value to allocate more space, and with a negative value to release
-previously allocated space if it is no longer required.
-@xref{Stubs}.
-
-RETURNS
-<<malloc>> returns a pointer to the newly allocated space, if
-successful; otherwise it returns <<NULL>>.  If your application needs
-to generate empty objects, you may use <<malloc(0)>> for this purpose.
-
-<<realloc>> returns a pointer to the new block of memory, or <<NULL>>
-if a new block could not be allocated.  <<NULL>> is also the result
-when you use `<<realloc(<[aptr]>,0)>>' (which has the same effect as
-`<<free(<[aptr]>)>>').  You should always check the result of
-<<realloc>>; successful reallocation is not guaranteed even when
-you request a smaller object.
-
-<<free>> does not return a result.
-
-<<memalign>> returns a pointer to the newly allocated space.
-
-<<malloc_usable_size>> returns the usable size.
-
-PORTABILITY
-<<malloc>>, <<realloc>>, and <<free>> are specified by the ANSI C
-standard, but other conforming implementations of <<malloc>> may
-behave differently when <[nbytes]> is zero.
-
-<<memalign>> is part of SVR4.
-
-<<malloc_usable_size>> is not portable.
-
-Supporting OS subroutines required: <<sbrk>>.  */
-
-#include <_ansi.h>
-#include <reent.h>
-#include <stdlib.h>
-#include <malloc.h>
-
-#ifndef _REENT_ONLY
-
-_PTR
-_DEFUN (malloc, (nbytes),
-	size_t nbytes)		/* get a block */
-{
-  return _malloc_r (_REENT, nbytes);
-}
-
-void
-_DEFUN (free, (aptr),
-	_PTR aptr)
-{
-  _free_r (_REENT, aptr);
-}
-
-#endif
-
-#endif /* ! defined (MALLOC_PROVIDED) */
+/*
+ * Kevin Lange's Slab Allocator
+ *
+ * Implemented for CS241, Fall 2010, machine problem 7
+ * at the University of Illinois, Urbana-Champaign.
+ *
+ * Overall competition winner for speed.
+ * Well ranked in memory usage.
+ *
+ * XXX: Modified to work withe the ToAru kernel.
+ *
+ * Copyright (c) 2010 Kevin Lange.  All rights reserved.
+ *
+ * Developed by: Kevin Lange <lange7@acm.uiuc.edu>
+ *               Dave Majnemer <dmajnem2@acm.uiuc.edu>
+ *               Assocation for Computing Machinery
+ *               University of Illinois, Urbana-Champaign
+ *               http://acm.uiuc.edu
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal with the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *   1. Redistributions of source code must retain the above copyright notice,
+ *      this list of conditions and the following disclaimers.
+ *   2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimers in the
+ *      documentation and/or other materials provided with the distribution.
+ *   3. Neither the names of the Association for Computing Machinery, the
+ *      University of Illinois, nor the names of its contributors may be used
+ *      to endorse or promote products derived from this Software without
+ *      specific prior written permission.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * WITH THE SOFTWARE.
+ *
+ * ##########
+ * # README #
+ * ##########
+ *
+ * About the slab allocator
+ * """"""""""""""""""""""""
+ *
+ * This is a simple implementation of a "slab" allocator. It works by operating
+ * on "bins" of items of predefined sizes and a set of pseudo-bins of any size.
+ * When a new allocation request is made, the allocator determines if it will
+ * fit in an existing bin. If there are no bins of the correct size for a given
+ * allocation request, the allocator will make a bin and add it to a(n empty)
+ * list of available bins of that size. In this implementation, we use sizes
+ * from 4 bytes (32 bit) or 8 bytes (64-bit) to 2KB for bins, fitting a 4K page
+ * size. The implementation allows the number of pages in a single bin to be
+ * increased, as well as allowing for changing the size of page (though this
+ * should, for the most part, remain 4KB under any modern system).
+ *
+ * Special thanks
+ * """"""""""""""
+ *
+ * I would like to thank Dave Majnemer, who I have credited above as a
+ * contributor, for his assistance. Without Dave, klmalloc would be a mash
+ * up of bits of forward movement in no discernible pattern. Dave helped
+ * me ensure that I could build a proper slab allocator and has consantly
+ * derided me for not fixing the bugs and to-do items listed in the last
+ * section of this readme.
+ *
+ * GCC Function Attributes
+ * """""""""""""""""""""""
+ *
+ * A couple of GCC function attributes, designated by the __attribute__
+ * directive, are used in this code to streamline optimization.
+ * I've chosen to include a brief overview of the particular attributes
+ * I am making use of:
+ *
+ * - malloc:
+ *   Tells gcc that a given function is a memory allocator
+ *   and that non-NULL values it returns should never be
+ *   associated with other chunks of memory. We use this for
+ *   alloc, realloc and calloc, as is requested in the gcc
+ *   documentation for the attribute.
+ *
+ * - always_inline:
+ *   Tells gcc to always inline the given code, regardless of the
+ *   optmization level. Small functions that would be noticeably
+ *   slower with the overhead of paramter handling are given
+ *   this attribute.
+ *
+ * - pure:
+ *   Tells gcc that a function only uses inputs and its output.
+ *
+ * Things to work on
+ * """""""""""""""""
+ *
+ * TODO: Try to be more consistent on comment widths...
+ * FIXME: Make thread safe! Not necessary for competition, but would be nice.
+ * FIXME: Splitting/coalescing is broken. Fix this ASAP!
+ *
+**/
+
+#define _XOPEN_SOURCE 700
+
+/* Includes {{{ */
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+#include <limits.h>
+#include <assert.h>
+#include <stdio.h>
+/* }}} */
+/* Definitions {{{ */
+
+/*
+ * Defines for often-used integral values
+ * related to our binning and paging strategy.
+ */
+#define NUM_BINS 1U								/* Number of bins, total, under 32-bit. */
+#define SMALLEST_BIN_LOG 2U							/* Logarithm base two of the smallest bin: log_2(sizeof(int32)). */
+#define BIG_BIN (NUM_BINS - 1)						/* Index for the big bin, (NUM_BINS - 1) */
+#define SMALLEST_BIN (1UL << SMALLEST_BIN_LOG)		/* Size of the smallest bin. */
+
+#define PAGE_SIZE 0x1000							/* Size of a page (in bytes), should be 4KB */
+#define PAGE_MASK (PAGE_SIZE - 1)					/* Block mask, size of a page * number of pages - 1. */
+#define SKIP_P INT32_MAX							/* INT32_MAX is half of UINT32_MAX; this gives us a 50% marker for skip lists. */
+#define SKIP_MAX_LEVEL 6							/* We have a maximum of 6 levels in our skip lists. */
+
+/* }}} */
+
+/*
+ * Internal functions.
+ */
+static void * __attribute__ ((malloc)) klmalloc(size_t size);
+static void * __attribute__ ((malloc)) klrealloc(void * ptr, size_t size);
+static void * __attribute__ ((malloc)) klcalloc(size_t nmemb, size_t size);
+static void * __attribute__ ((malloc)) klvalloc(size_t size);
+static void klfree(void * ptr);
+
+void * __attribute__ ((malloc)) malloc(size_t size) {
+	return klmalloc(size);
+}
+
+void * __attribute__ ((malloc)) realloc(void * ptr, size_t size) {
+	return klrealloc(ptr, size);
+}
+
+void * __attribute__ ((malloc)) calloc(size_t nmemb, size_t size) {
+	return klcalloc(nmemb, size);
+}
+
+void * __attribute__ ((malloc)) valloc(size_t size) {
+	return klvalloc(size);
+}
+
+void free(void * ptr) {
+	klfree(ptr);
+}
+
+
+/* Bin management {{{ */
+
+/*
+ * Adjust bin size in bin_size call to proper bounds.
+ */
+static size_t  __attribute__ ((always_inline, pure)) klmalloc_adjust_bin(size_t bin)
+{
+	if (bin <= (size_t)SMALLEST_BIN_LOG)
+	{
+		return 0;
+	}
+	bin -= SMALLEST_BIN_LOG + 1;
+	if (bin > (size_t)BIG_BIN) {
+		return BIG_BIN;
+	}
+	return bin;
+}
+
+/*
+ * Given a size value, find the correct bin
+ * to place the requested allocation in.
+ */
+static size_t __attribute__ ((always_inline, pure)) klmalloc_bin_size(size_t size) {
+	size_t bin = sizeof(size) * CHAR_BIT - __builtin_clzl(size);
+	bin += !!(size & (size - 1));
+	return klmalloc_adjust_bin(bin);
+}
+
+/*
+ * Bin header - One page of memory.
+ * Appears at the front of a bin to point to the
+ * previous bin (or NULL if the first), the next bin
+ * (or NULL if the last) and the head of the bin, which
+ * is a stack of cells of data.
+ */
+typedef struct _klmalloc_bin_header {
+	struct _klmalloc_bin_header *  next;	/* Pointer to the next node. */
+	void * head;							/* Head of this bin. */
+	size_t size;							/* Size of this bin, if big; otherwise bin index. */
+} klmalloc_bin_header;
+
+/*
+ * A big bin header is basically the same as a regular bin header
+ * only with a pointer to the previous (physically) instead of
+ * a "next" and with a list of forward headers.
+ */
+typedef struct _klmalloc_big_bin_header {
+	struct _klmalloc_big_bin_header * next;
+	void * head;
+	size_t size;
+	struct _klmalloc_big_bin_header * prev;
+	struct _klmalloc_big_bin_header * forward[SKIP_MAX_LEVEL+1];
+} klmalloc_big_bin_header;
+
+
+/*
+ * List of pages in a bin.
+ */
+typedef struct _klmalloc_bin_header_head {
+	klmalloc_bin_header * first;
+} klmalloc_bin_header_head;
+
+/*
+ * Array of available bins.
+ */
+static klmalloc_bin_header_head klmalloc_bin_head[NUM_BINS - 1];	/* Small bins */
+static struct _klmalloc_big_bins {
+	klmalloc_big_bin_header head;
+	int level;
+} klmalloc_big_bins;
+static klmalloc_big_bin_header * klmalloc_newest_big = NULL;		/* Newest big bin */
+
+/* }}} Bin management */
+/* Doubly-Linked List {{{ */
+
+/*
+ * Remove an entry from a page list.
+ * Decouples the element from its
+ * position in the list by linking
+ * its neighbors to eachother.
+ */
+static void __attribute__ ((always_inline)) klmalloc_list_decouple(klmalloc_bin_header_head *head, klmalloc_bin_header *node) {
+	klmalloc_bin_header *next	= node->next;
+	head->first = next;
+	node->next = NULL;
+}
+
+/*
+ * Insert an entry into a page list.
+ * The new entry is placed at the front
+ * of the list and the existing border
+ * elements are updated to point back
+ * to it (our list is doubly linked).
+ */
+static void __attribute__ ((always_inline)) klmalloc_list_insert(klmalloc_bin_header_head *head, klmalloc_bin_header *node) {
+	node->next = head->first;
+	head->first = node;
+}
+
+/*
+ * Get the head of a page list.
+ * Because redundant function calls
+ * are really great, and just in case
+ * we change the list implementation.
+ */
+static klmalloc_bin_header * __attribute__ ((always_inline)) klmalloc_list_head(klmalloc_bin_header_head *head) {
+	return head->first;
+}
+
+/* }}} Lists */
+/* Skip List {{{ */
+
+/*
+ * Skip lists are efficient
+ * data structures for storing
+ * and searching ordered data.
+ *
+ * Here, the skip lists are used
+ * to keep track of big bins.
+ */
+
+/*
+ * Generate a random value in an appropriate range.
+ * This is a xor-shift RNG.
+ */
+static uint32_t __attribute__ ((pure)) klmalloc_skip_rand() {
+	static uint32_t x = 123456789;
+	static uint32_t y = 362436069;
+	static uint32_t z = 521288629;
+	static uint32_t w = 88675123;
+
+	uint32_t t;
+
+	t = x ^ (x << 11);
+	x = y; y = z; z = w;
+	return w = w ^ (w >> 19) ^ t ^ (t >> 8);
+}
+
+/*
+ * Generate a random level for a skip node
+ */
+static int __attribute__ ((pure, always_inline)) klmalloc_random_level() {
+	int level = 0;
+	/*
+	 * Keep trying to check rand() against 50% of its maximum.
+	 * This provides 50%, 25%, 12.5%, etc. chance for each level.
+	 */
+	while (klmalloc_skip_rand() < SKIP_P && level < SKIP_MAX_LEVEL) {
+		++level;
+	}
+	return level;
+}
+
+/*
+ * Find best fit for a given value.
+ */
+static klmalloc_big_bin_header * klmalloc_skip_list_findbest(size_t search_size) {
+	klmalloc_big_bin_header * node = &klmalloc_big_bins.head;
+	/*
+	 * Loop through the skip list until we hit something > our search value.
+	 */
+	int i;
+	for (i = klmalloc_big_bins.level; i >= 0; --i) {
+		while (node->forward[i] && (node->forward[i]->size < search_size)) {
+			node = node->forward[i];
+			if (node)
+				assert((node->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+		}
+	}
+	/*
+	 * This value will either be NULL (we found nothing)
+	 * or a node (we found a minimum fit).
+	 */
+	node = node->forward[0];
+	if (node) {
+		assert((uintptr_t)node % PAGE_SIZE == 0);
+		assert((node->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+	}
+	return node;
+}
+
+/*
+ * Insert a header into the skip list.
+ */
+static void klmalloc_skip_list_insert(klmalloc_big_bin_header * value) {
+	/*
+	 * You better be giving me something valid to insert,
+	 * or I will slit your ****ing throat.
+	 */
+	assert(value != NULL);
+	assert(value->head != NULL);
+	assert((uintptr_t)value->head > (uintptr_t)value);
+	if (value->size > NUM_BINS) {
+		assert((uintptr_t)value->head < (uintptr_t)value + value->size);
+	} else {
+		assert((uintptr_t)value->head < (uintptr_t)value + PAGE_SIZE);
+	}
+	assert((uintptr_t)value % PAGE_SIZE == 0);
+	assert((value->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+	assert(value->size != 0);
+
+	/*
+	 * Starting from the head node of the bin locator...
+	 */
+	klmalloc_big_bin_header * node = &klmalloc_big_bins.head;
+	klmalloc_big_bin_header * update[SKIP_MAX_LEVEL + 1];
+
+	/*
+	 * Loop through the skiplist to find the right place
+	 * to insert the node (where ->forward[] > value)
+	 */
+	int i;
+	for (i = klmalloc_big_bins.level; i >= 0; --i) {
+		while (node->forward[i] && node->forward[i]->size < value->size) {
+			node = node->forward[i];
+			if (node)
+				assert((node->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+		}
+		update[i] = node;
+	}
+	node = node->forward[0];
+
+	/*
+	 * Make the new skip node and update
+	 * the forward values.
+	 */
+	if (node != value) {
+		int level = klmalloc_random_level();
+		/*
+		 * Get all of the nodes before this.
+		 */
+		if (level > klmalloc_big_bins.level) {
+			for (i = klmalloc_big_bins.level + 1; i <= level; ++i) {
+				update[i] = &klmalloc_big_bins.head;
+			}
+			klmalloc_big_bins.level = level;
+		}
+
+		/*
+		 * Make the new node.
+		 */
+		node = value;
+
+		/*
+		 * Run through and point the preceeding nodes
+		 * for each level to the new node.
+		 */
+		for (i = 0; i <= level; ++i) {
+			node->forward[i] = update[i]->forward[i];
+			if (node->forward[i])
+				assert((node->forward[i]->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+			update[i]->forward[i] = node;
+		}
+	}
+}
+
+/*
+ * Delete a header from the skip list.
+ * Be sure you didn't change the size, or we won't be able to find it.
+ */
+static void klmalloc_skip_list_delete(klmalloc_big_bin_header * value) {
+	/*
+	 * Debug assertions
+	 */
+	assert(value != NULL);
+	assert(value->head);
+	assert((uintptr_t)value->head > (uintptr_t)value);
+	if (value->size > NUM_BINS) {
+		assert((uintptr_t)value->head < (uintptr_t)value + value->size);
+	} else {
+		assert((uintptr_t)value->head < (uintptr_t)value + PAGE_SIZE);
+	}
+
+	/*
+	 * Starting from the bin header, again...
+	 */
+	klmalloc_big_bin_header * node = &klmalloc_big_bins.head;
+	klmalloc_big_bin_header * update[SKIP_MAX_LEVEL + 1];
+
+	/*
+	 * Find the node.
+	 */
+	int i;
+	for (i = klmalloc_big_bins.level; i >= 0; --i) {
+		while (node->forward[i] && node->forward[i]->size < value->size) {
+			node = node->forward[i];
+			if (node)
+				assert((node->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+		}
+		update[i] = node;
+	}
+	node = node->forward[0];
+	while (node != value) {
+		node = node->forward[0];
+	}
+
+	if (node != value) {
+		node = klmalloc_big_bins.head.forward[0];
+		while (node->forward[0] && node->forward[0] != value) {
+			node = node->forward[0];
+		}
+		node = node->forward[0];
+	}
+	/*
+	 * If we found the node, delete it;
+	 * otherwise, we do nothing.
+	 */
+	if (node == value) {
+		for (i = 0; i <= klmalloc_big_bins.level; ++i) {
+			if (update[i]->forward[i] != node) {
+				break;
+			}
+			update[i]->forward[i] = node->forward[i];
+			if (update[i]->forward[i]) {
+				assert((uintptr_t)(update[i]->forward[i]) % PAGE_SIZE == 0);
+				assert((update[i]->forward[i]->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+			}
+		}
+
+		while (klmalloc_big_bins.level > 0 && klmalloc_big_bins.head.forward[klmalloc_big_bins.level] == NULL) {
+			--klmalloc_big_bins.level;
+		}
+	}
+}
+
+/* }}} */
+/* Stack {{{ */
+/*
+ * Pop an item from a block.
+ * Free space is stored as a stack,
+ * so we get a free space for a bin
+ * by popping a free node from the
+ * top of the stack.
+ */
+static void * klmalloc_stack_pop(klmalloc_bin_header *header) {
+	assert(header);
+	assert(header->head != NULL);
+	assert((uintptr_t)header->head > (uintptr_t)header);
+	if (header->size > NUM_BINS) {
+		assert((uintptr_t)header->head < (uintptr_t)header + header->size);
+	} else {
+		assert((uintptr_t)header->head < (uintptr_t)header + PAGE_SIZE);
+	}
+	
+	/*
+	 * Remove the current head and point
+	 * the head to where the old head pointed.
+	 */
+	void *item = header->head;
+	size_t **head = header->head;
+	size_t *next = *head;
+	header->head = next;
+	return item;
+}
+
+/*
+ * Push an item into a block.
+ * When we free memory, we need
+ * to add the freed cell back
+ * into the stack of free spaces
+ * for the block.
+ */
+static void klmalloc_stack_push(klmalloc_bin_header *header, void *ptr) {
+	assert(ptr != NULL);
+	assert((uintptr_t)ptr > (uintptr_t)header);
+	if (header->size > NUM_BINS) {
+		assert((uintptr_t)ptr < (uintptr_t)header + header->size);
+	} else {
+		assert((uintptr_t)ptr < (uintptr_t)header + PAGE_SIZE);
+	}
+	size_t **item = (size_t **)ptr;
+	*item = (size_t *)header->head;
+	header->head = item;
+}
+
+/*
+ * Is this cell stack empty?
+ * If the head of the stack points
+ * to NULL, we have exhausted the
+ * stack, so there is no more free
+ * space available in the block.
+ */
+static int __attribute__ ((always_inline)) klmalloc_stack_empty(klmalloc_bin_header *header) {
+	return header->head == NULL;
+}
+
+/* }}} Stack */
+
+/* malloc() {{{ */
+static void * __attribute__ ((malloc)) klmalloc(size_t size) {
+	/*
+	 * C standard implementation:
+	 * If size is zero, we can choose do a number of things.
+	 * This implementation will return a NULL pointer.
+	 */
+	if (__builtin_expect(size == 0, 0))
+		return NULL;
+
+	/*
+	 * Find the appropriate bin for the requested
+	 * allocation and start looking through that list.
+	 */
+	unsigned int bucket_id = klmalloc_bin_size(size);
+
+	if (bucket_id < BIG_BIN) {
+		/*
+		 * Small bins.
+		 */
+		klmalloc_bin_header * bin_header = klmalloc_list_head(&klmalloc_bin_head[bucket_id]);
+		if (!bin_header) {
+			/*
+			 * Grow the heap for the new bin.
+			 */
+			bin_header = (klmalloc_bin_header*)sbrk(PAGE_SIZE);
+			assert(bin_header != NULL);
+			assert((uintptr_t)bin_header % PAGE_SIZE == 0);
+
+			/*
+			 * Set the head of the stack.
+			 */
+			bin_header->head = (void*)((uintptr_t)bin_header + sizeof(klmalloc_bin_header));
+			/*
+			 * Insert the new bin at the front of
+			 * the list of bins for this size.
+			 */
+			klmalloc_list_insert(&klmalloc_bin_head[bucket_id], bin_header);
+			/*
+			 * Initialize the stack inside the bin.
+			 * The stack is initially full, with each
+			 * entry pointing to the next until the end
+			 * which points to NULL.
+			 */
+			size_t adj = SMALLEST_BIN_LOG + bucket_id;
+			size_t i, available = ((PAGE_SIZE - sizeof(klmalloc_bin_header)) >> adj) - 1;
+
+			size_t **base = bin_header->head;
+			for (i = 0; i < available; ++i) {
+				/*
+				 * Our available memory is made into a stack, with each
+				 * piece of memory turned into a pointer to the next
+				 * available piece. When we want to get a new piece
+				 * of memory from this block, we just pop off a free
+				 * spot and give its address.
+				 */
+				base[i << bucket_id] = (size_t *)&base[(i + 1) << bucket_id];
+			}
+			base[available << bucket_id] = NULL;
+			bin_header->size = bucket_id;
+		}
+		size_t ** item = klmalloc_stack_pop(bin_header);
+		if (klmalloc_stack_empty(bin_header)) {
+			klmalloc_list_decouple(&(klmalloc_bin_head[bucket_id]),bin_header);
+		}
+		return item;
+	} else {
+		/*
+		 * Big bins.
+		 */
+		klmalloc_big_bin_header * bin_header = klmalloc_skip_list_findbest(size);
+		if (bin_header) {
+			assert(bin_header->size >= size);
+			/*
+			 * If we found one, delete it from the skip list
+			 */
+			klmalloc_skip_list_delete(bin_header);
+			/*
+			 * Retreive the head of the block.
+			 */
+			size_t ** item = klmalloc_stack_pop((klmalloc_bin_header *)bin_header);
+#if 0
+			/*
+			 * Resize block, if necessary
+			 */
+			assert(bin_header->head == NULL);
+			size_t old_size = bin_header->size;
+			//size_t rsize = size;
+			/*
+			 * Round the requeste size to our full required size.
+			 */
+			size = ((size + sizeof(klmalloc_big_bin_header)) / PAGE_SIZE + 1) * PAGE_SIZE - sizeof(klmalloc_big_bin_header);
+			assert((size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+			if (bin_header->size > size * 2) {
+				assert(old_size != size);
+				/*
+				 * If we have extra space, start splitting.
+				 */
+				bin_header->size = size;
+				assert(sbrk(0) >= bin_header->size + (uintptr_t)bin_header);
+				/*
+				 * Make a new block at the end of the needed space.
+				 */
+				klmalloc_big_bin_header * header_new = (klmalloc_big_bin_header *)((uintptr_t)bin_header + sizeof(klmalloc_big_bin_header) + size);
+				assert((uintptr_t)header_new % PAGE_SIZE == 0);
+				memset(header_new, 0, sizeof(klmalloc_big_bin_header) + sizeof(void *));
+				header_new->prev = bin_header;
+				if (bin_header->next) {
+					bin_header->next->prev = header_new;
+				}
+				header_new->next = bin_header->next;
+				bin_header->next = header_new;
+				if (klmalloc_newest_big == bin_header) {
+					klmalloc_newest_big = header_new;
+				}
+				header_new->size = old_size - (size + sizeof(klmalloc_big_bin_header));
+				assert(((uintptr_t)header_new->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+				fprintf(stderr, "Splitting %p [now %zx] at %p [%zx] from [%zx,%zx].\n", (void*)bin_header, bin_header->size, (void*)header_new, header_new->size, old_size, size);
+				/*
+				 * Free the new block.
+				 */
+				klfree((void *)((uintptr_t)header_new + sizeof(klmalloc_big_bin_header)));
+			}
+#endif
+			return item;
+		} else {
+			/*
+			 * Round requested size to a set of pages, plus the header size.
+			 */
+			size_t pages = (size + sizeof(klmalloc_big_bin_header)) / PAGE_SIZE + 1;
+			bin_header = (klmalloc_big_bin_header*)sbrk(PAGE_SIZE * pages);
+			assert((uintptr_t)bin_header % PAGE_SIZE == 0);
+			/*
+			 * Give the header the remaining space.
+			 */
+			bin_header->size = pages * PAGE_SIZE - sizeof(klmalloc_big_bin_header);
+			assert((bin_header->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+			/*
+			 * Link the block in physical memory.
+			 */
+			bin_header->prev = klmalloc_newest_big;
+			if (bin_header->prev) {
+				bin_header->prev->next = bin_header;
+			}
+			klmalloc_newest_big = bin_header;
+			bin_header->next = NULL;
+			/*
+			 * Return the head of the block.
+			 */
+			bin_header->head = NULL;
+			return (void*)((uintptr_t)bin_header + sizeof(klmalloc_big_bin_header));
+		}
+	}
+}
+/* }}} */
+/* free() {{{ */
+static void klfree(void *ptr) {
+	/*
+	 * C standard implementation: Do nothing when NULL is passed to free.
+	 */
+	if (__builtin_expect(ptr == NULL, 0)) {
+		return;
+	}
+
+	/*
+	 * Woah, woah, hold on, was this a page-aligned block?
+	 */
+	if ((uintptr_t)ptr % PAGE_SIZE == 0) {
+		/*
+		 * Well howdy-do, it was.
+		 */
+		ptr = (void *)((uintptr_t)ptr - 1);
+	}
+
+	/*
+	 * Get our pointer to the head of this block by
+	 * page aligning it.
+	 */
+	klmalloc_bin_header * header = (klmalloc_bin_header *)((uintptr_t)ptr & (size_t)~PAGE_MASK);
+	assert((uintptr_t)header % PAGE_SIZE == 0);
+
+	/*
+	 * For small bins, the bin number is stored in the size
+	 * field of the header. For large bins, the actual size
+	 * available in the bin is stored in this field. It's
+	 * easy to tell which is which, though.
+	 */
+	size_t bucket_id = header->size;
+	if (bucket_id > (size_t)NUM_BINS) {
+		bucket_id = BIG_BIN;
+		klmalloc_big_bin_header *bheader = (klmalloc_big_bin_header*)header;
+		
+		assert(bheader);
+		assert(bheader->head == NULL);
+		assert((bheader->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+		/*
+		 * Coalesce forward blocks into us.
+		 */
+#if 0
+		if (bheader != klmalloc_newest_big) {
+			/*
+			 * If we are not the newest big bin, there is most definitely
+			 * something in front of us that we can read.
+			 */
+			assert((bheader->size + sizeof(klmalloc_big_bin_header)) % PAGE_SIZE == 0);
+			klmalloc_big_bin_header * next = (void *)((uintptr_t)bheader + sizeof(klmalloc_big_bin_header) + bheader->size);
+			assert((uintptr_t)next % PAGE_SIZE == 0);
+			if (next == bheader->next && next->head) { //next->size > NUM_BINS && next->head) {
+				/*
+				 * If that something is an available big bin, we can
+				 * coalesce it into us to form one larger bin.
+				 */
+
+				// XXX
+				size_t old_size = bheader->size;
+				// XXX
+
+				klmalloc_skip_list_delete(next);
+				bheader->size = (size_t)bheader->size + (size_t)sizeof(klmalloc_big_bin_header) + next->size;
+				assert((bheader->size + sizeof(klmalloc_big_bin_header))  % PAGE_SIZE == 0);
+
+				if (next == klmalloc_newest_big) {
+					/*
+					 * If the guy in front of us was the newest,
+					 * we are now the newest (as we are him).
+					 */
+					klmalloc_newest_big = bheader;
+				} else {
+					if (next->next) {
+						next->next->prev = bheader;
+					}
+				}
+				fprintf(stderr,"Coelesced (forwards)  %p [%zx] <- %p [%zx] = %zx\n", (void*)bheader, old_size, (void*)next, next->size, bheader->size);
+			}
+		}
+#endif
+		/*
+		 * Coalesce backwards
+		 */
+#if 0
+		if (bheader->prev && bheader->prev->head) {
+			/*
+			 * If there is something behind us, it is available, and there is nothing between
+			 * it and us, we can coalesce ourselves into it to form a big block.
+			 */
+			if ((uintptr_t)bheader->prev + (bheader->prev->size + sizeof(klmalloc_big_bin_header)) == (uintptr_t)bheader) {
+
+				size_t old_size = bheader->prev->size;
+
+				klmalloc_skip_list_delete(bheader->prev);
+				bheader->prev->size = (size_t)bheader->prev->size + (size_t)bheader->size + sizeof(klmalloc_big_bin_header);
+				assert((bheader->prev->size + sizeof(klmalloc_big_bin_header))  % PAGE_SIZE == 0);
+				klmalloc_skip_list_insert(bheader->prev);
+				if (klmalloc_newest_big == bheader) {
+					klmalloc_newest_big = bheader->prev;
+				} else {
+					if (bheader->next) {
+						bheader->next->prev = bheader->prev;
+					}
+				}
+				fprintf(stderr,"Coelesced (backwards) %p [%zx] <- %p [%zx] = %zx\n", (void*)bheader->prev, old_size, (void*)bheader, bheader->size, bheader->size);
+				/*
+				 * If we coalesced backwards, we are done.
+				 */
+				return;
+			}
+		}
+#endif
+		/*
+		 * Push new space back into the stack.
+		 */
+		klmalloc_stack_push((klmalloc_bin_header *)bheader, (void *)((uintptr_t)bheader + sizeof(klmalloc_big_bin_header)));
+		assert(bheader->head != NULL);
+		/*
+		 * Insert the block into list of available slabs.
+		 */
+		klmalloc_skip_list_insert(bheader);
+	} else {
+		/*
+		 * If the stack is empty, we are freeing
+		 * a block from a previously full bin.
+		 * Return it to the busy bins list.
+		 */
+		if (klmalloc_stack_empty(header)) {
+			klmalloc_list_insert(&klmalloc_bin_head[bucket_id], header);
+		}
+		/*
+		 * Push new space back into the stack.
+		 */
+		klmalloc_stack_push(header, ptr);
+	}
+}
+/* }}} */
+/* valloc() {{{ */
+static void * __attribute__ ((malloc)) klvalloc(size_t size) {
+	/*
+	 * Allocate a page-aligned block.
+	 * XXX: THIS IS HORRIBLY, HORRIBLY WASTEFUL!! ONLY USE THIS
+	 *      IF YOU KNOW WHAT YOU ARE DOING!
+	 */
+	size_t true_size = size + PAGE_SIZE - sizeof(klmalloc_big_bin_header); /* Here we go... */
+	void * result = klmalloc(true_size);
+	return (void *)((uintptr_t)result + (PAGE_SIZE - sizeof(klmalloc_big_bin_header)));
+}
+/* }}} */
+/* realloc() {{{ */
+static void * __attribute__ ((malloc)) klrealloc(void *ptr, size_t size) {
+	/*
+	 * C standard implementation: When NULL is passed to realloc,
+	 * simply malloc the requested size and return a pointer to that.
+	 */
+	if (__builtin_expect(ptr == NULL, 0))
+		return malloc(size);
+
+	/*
+	 * C standard implementation: For a size of zero, free the
+	 * pointer and return NULL, allocating no new memory.
+	 */
+	if (__builtin_expect(size == 0, 0))
+	{
+		free(ptr);
+		return NULL;
+	}
+
+	/*
+	 * Find the bin for the given pointer
+	 * by aligning it to a page.
+	 */
+	klmalloc_bin_header * header_old = (void *)((uintptr_t)ptr & (size_t)~PAGE_MASK);
+
+
+	/*
+	 * (This will only happen for a big bin, mathematically speaking)
+	 * If we still have room in our bin for the additonal space,
+	 * we don't need to do anything.
+	 */
+	if (header_old->size >= size) {
+
+		/*
+		 * TODO: Break apart blocks here, which is far more important
+		 *       than breaking them up on allocations.
+		 */
+		return ptr;
+	}
+
+	/*
+	 * Reallocate more memory.
+	 */
+	void * newptr = klmalloc(size);
+	if (__builtin_expect(newptr != NULL, 1)) {
+		size_t old_size = header_old->size;
+		if (old_size < (size_t)BIG_BIN) {
+			/*
+			 * If we are copying from a small bin,
+			 * we need to get the size of the bin
+			 * from its id.
+			 */
+			old_size = (1UL << (SMALLEST_BIN_LOG + old_size));
+		}
+
+		/*
+		 * Copy the old value into the new value.
+		 * Be sure to only copy as much as was in
+		 * the old block.
+		 */
+		memcpy(newptr, ptr, old_size);
+		klfree(ptr);
+		return newptr;
+	}
+
+	/*
+	 * We failed to allocate more memory,
+	 * which means we're probably out.
+	 *
+	 * Bail and return NULL.
+	 */
+	return NULL;
+}
+/* }}} */
+/* calloc() {{{ */
+static void * __attribute__ ((malloc)) klcalloc(size_t nmemb, size_t size) {
+	/*
+	 * Allocate memory and zero it before returning
+	 * a pointer to the newly allocated memory.
+	 * 
+	 * Implemented by way of a simple malloc followed
+	 * by a memset to 0x00 across the length of the
+	 * requested memory chunk.
+	 */
+
+	fprintf(stderr,"Oh, what a rare oddity this is. Someone has called calloc.\n");
+
+	void *ptr = klmalloc(nmemb * size);
+	if (__builtin_expect(ptr != NULL, 1))
+		memset(ptr,0x00,nmemb * size);
+	return ptr;
+}
+/* }}} */
+
+
+/*
+ * vim:noexpandtab
+ * vim:tabstop=4
+ * vim:shiftwidth=4
+ */
diff -rupN _source/newlib-1.19.0/newlib/libc/stdlib/mallocr.c newlib-1.19.0/newlib/libc/stdlib/mallocr.c
--- _source/newlib-1.19.0/newlib/libc/stdlib/mallocr.c	2010-05-31 14:15:41.000000000 -0500
+++ newlib-1.19.0/newlib/libc/stdlib/mallocr.c	2011-04-30 21:28:46.000000000 -0500
@@ -609,8 +609,11 @@ do {
   operating system immediately after a free().
 */
 
+#define HAVE_MMAP 0
+#define HAVE_MREMAP 0
+
 #ifndef HAVE_MMAP
-#define HAVE_MMAP 1
+#define HAVE_MMAP 0
 #endif
 
 /*
diff -rupN _source/newlib-1.19.0/newlib/libc/sys/configure newlib-1.19.0/newlib/libc/sys/configure
--- _source/newlib-1.19.0/newlib/libc/sys/configure	2010-12-16 15:59:03.000000000 -0600
+++ newlib-1.19.0/newlib/libc/sys/configure	2011-04-24 20:39:58.000000000 -0500
@@ -1,11 +1,11 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.65 for newlib 1.19.0.
+# Generated by GNU Autoconf 2.67 for newlib 1.19.0.
 #
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation,
-# Inc.
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
+# Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -324,7 +324,7 @@ $as_echo X"$as_dir" |
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -364,19 +364,19 @@ else
 fi # as_fn_arith
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -540,7 +540,7 @@ test -n "$DJDIR" || exec 7<&0 </dev/null
 exec 6>&1
 
 # Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
@@ -798,6 +798,7 @@ sysvi386
 sysvnecv70
 tic80
 w65
+toaru
 z8ksim'
 
 # Initialize some variables set by options.
@@ -860,8 +861,9 @@ do
   fi
 
   case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
   esac
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
@@ -906,7 +908,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -932,7 +934,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1136,7 +1138,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1152,7 +1154,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1182,8 +1184,8 @@ do
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) as_fn_error "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information."
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
     ;;
 
   *=*)
@@ -1191,7 +1193,7 @@ Try \`$0 --help' for more information."
     # Reject names that are not valid shell variable names.
     case $ac_envvar in #(
       '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
     esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
@@ -1209,13 +1211,13 @@ done
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error "missing argument to $ac_option"
+  as_fn_error $? "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1238,7 +1240,7 @@ do
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1252,8 +1254,8 @@ target=$target_alias
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
+    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used" >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1268,9 +1270,9 @@ test "$silent" = yes && exec 6>/dev/null
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error "working directory cannot be determined"
+  as_fn_error $? "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error "pwd does not report name of working directory"
+  as_fn_error $? "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1309,11 +1311,11 @@ else
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1353,7 +1355,7 @@ Configuration:
       --help=short        display options specific to this package
       --help=recursive    display the short help of all the included packages
   -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
+  -q, --quiet, --silent   do not print \`checking ...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for \`--cache-file=config.cache'
   -n, --no-create         do not create output files
@@ -1521,9 +1523,9 @@ test -n "$ac_init_help" && exit $ac_stat
 if $ac_init_version; then
   cat <<\_ACEOF
 newlib configure 1.19.0
-generated by GNU Autoconf 2.65
+generated by GNU Autoconf 2.67
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2010 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1627,7 +1629,7 @@ ac_fn_c_check_header_compile ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1670,7 +1672,7 @@ $as_echo "$ac_try_echo"; } >&5
     mv -f conftest.er1 conftest.err
   fi
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } >/dev/null && {
+  test $ac_status = 0; } > conftest.i && {
 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        }; then :
@@ -1736,7 +1738,7 @@ ac_fn_c_check_func ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -1799,7 +1801,7 @@ This file contains any messages produced
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by newlib $as_me 1.19.0, which was
-generated by GNU Autoconf 2.65.  Invocation command line was
+generated by GNU Autoconf 2.67.  Invocation command line was
 
   $ $0 $@
 
@@ -1909,11 +1911,9 @@ trap 'exit_status=$?
   {
     echo
 
-    cat <<\_ASBOX
-## ---------------- ##
+    $as_echo "## ---------------- ##
 ## Cache variables. ##
-## ---------------- ##
-_ASBOX
+## ---------------- ##"
     echo
     # The following way of writing the cache mishandles newlines in values,
 (
@@ -1947,11 +1947,9 @@ $as_echo "$as_me: WARNING: cache variabl
 )
     echo
 
-    cat <<\_ASBOX
-## ----------------- ##
+    $as_echo "## ----------------- ##
 ## Output variables. ##
-## ----------------- ##
-_ASBOX
+## ----------------- ##"
     echo
     for ac_var in $ac_subst_vars
     do
@@ -1964,11 +1962,9 @@ _ASBOX
     echo
 
     if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
+      $as_echo "## ------------------- ##
 ## File substitutions. ##
-## ------------------- ##
-_ASBOX
+## ------------------- ##"
       echo
       for ac_var in $ac_subst_files
       do
@@ -1982,11 +1978,9 @@ _ASBOX
     fi
 
     if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
+      $as_echo "## ----------- ##
 ## confdefs.h. ##
-## ----------- ##
-_ASBOX
+## ----------- ##"
       echo
       cat confdefs.h
       echo
@@ -2041,7 +2035,12 @@ _ACEOF
 ac_site_file1=NONE
 ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  ac_site_file1=$CONFIG_SITE
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
 elif test "x$prefix" != xNONE; then
   ac_site_file1=$prefix/share/config.site
   ac_site_file2=$prefix/etc/config.site
@@ -2056,7 +2055,11 @@ do
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
 $as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5 ; }
   fi
 done
 
@@ -2132,7 +2135,7 @@ if $ac_cache_corrupted; then
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
 fi
 ## -------------------- ##
 ## Main body of script. ##
@@ -2149,16 +2152,22 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 ac_aux_dir=
 for ac_dir in ../../.. "$srcdir"/../../..; do
-  for ac_t in install-sh install.sh shtool; do
-    if test -f "$ac_dir/$ac_t"; then
-      ac_aux_dir=$ac_dir
-      ac_install_sh="$ac_aux_dir/$ac_t -c"
-      break 2
-    fi
-  done
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
 done
 if test -z "$ac_aux_dir"; then
-  as_fn_error "cannot find install-sh, install.sh, or shtool in ../../.. \"$srcdir\"/../../.." "$LINENO" 5
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in ../../.. \"$srcdir\"/../../.." "$LINENO" 5
 fi
 
 # These three variables are undocumented and unsupported,
@@ -2174,7 +2183,7 @@ ac_configure="$SHELL $ac_aux_dir/configu
 
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
 $as_echo_n "checking build system type... " >&6; }
@@ -2185,16 +2194,16 @@ else
 test "x$ac_build_alias" = x &&
   ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
 test "x$ac_build_alias" = x &&
-  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
 ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
 $as_echo "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
-*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5 ;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
@@ -2219,7 +2228,7 @@ else
   ac_cv_host=$ac_cv_build
 else
   ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
@@ -2227,7 +2236,7 @@ fi
 $as_echo "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
-*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5 ;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
@@ -2349,11 +2358,11 @@ am_lf='
 '
 case `pwd` in
   *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
+    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5 ;;
 esac
 case $srcdir in
   *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5 ;;
 esac
 
 # Do `set' in a subshell so we don't clobber the current shell's
@@ -2375,7 +2384,7 @@ if (
       # if, for instance, CONFIG_SHELL is bash and it inherits a
       # broken ls alias from the environment.  This has actually
       # happened.  Such a system could not be considered "sane".
-      as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
 alias in your environment" "$LINENO" 5
    fi
 
@@ -2385,7 +2394,7 @@ then
    # Ok.
    :
 else
-   as_fn_error "newly created file is older than distributed files!
+   as_fn_error $? "newly created file is older than distributed files!
 Check your system clock" "$LINENO" 5
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
@@ -2623,7 +2632,7 @@ done
 $as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
 set x ${MAKE-make}
 ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat >conftest.make <<\_ACEOF
@@ -2631,7 +2640,7 @@ SHELL = /bin/sh
 all:
 	@echo '@@@%%%=$(MAKE)=@@@%%%'
 _ACEOF
-# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
 case `${MAKE-make} -f conftest.make 2>/dev/null` in
   *@@@%%%=?*=@@@%%%*)
     eval ac_cv_prog_make_${ac_make}_set=yes;;
@@ -2727,7 +2736,7 @@ if test "${enable_multilib+set}" = set;
   enableval=$enable_multilib; case "${enableval}" in
   yes) multilib=yes ;;
   no)  multilib=no ;;
-  *)   as_fn_error "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
+  *)   as_fn_error $? "bad value ${enableval} for multilib option" "$LINENO" 5  ;;
  esac
 else
   multilib=yes
@@ -2738,7 +2747,7 @@ if test "${enable_target_optspace+set}"
   enableval=$enable_target_optspace; case "${enableval}" in
   yes) target_optspace=yes ;;
   no)  target_optspace=no ;;
-  *)   as_fn_error "bad value ${enableval} for target-optspace option" "$LINENO" 5 ;;
+  *)   as_fn_error $? "bad value ${enableval} for target-optspace option" "$LINENO" 5  ;;
  esac
 else
   target_optspace=
@@ -2749,7 +2758,7 @@ if test "${enable_malloc_debugging+set}"
   enableval=$enable_malloc_debugging; case "${enableval}" in
   yes) malloc_debugging=yes ;;
   no)  malloc_debugging=no ;;
-  *)   as_fn_error "bad value ${enableval} for malloc-debugging option" "$LINENO" 5 ;;
+  *)   as_fn_error $? "bad value ${enableval} for malloc-debugging option" "$LINENO" 5  ;;
  esac
 else
   malloc_debugging=
@@ -2760,7 +2769,7 @@ if test "${enable_newlib_multithread+set
   enableval=$enable_newlib_multithread; case "${enableval}" in
   yes) newlib_multithread=yes ;;
   no)  newlib_multithread=no ;;
-  *)   as_fn_error "bad value ${enableval} for newlib-multithread option" "$LINENO" 5 ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-multithread option" "$LINENO" 5  ;;
  esac
 else
   newlib_multithread=yes
@@ -2772,7 +2781,7 @@ if test "${enable_newlib_iconv+set}" = s
    case "${enableval}" in
      yes) newlib_iconv=yes ;;
      no)  newlib_iconv=no ;;
-     *)   as_fn_error "bad value ${enableval} for newlib-iconv option" "$LINENO" 5 ;;
+     *)   as_fn_error $? "bad value ${enableval} for newlib-iconv option" "$LINENO" 5  ;;
    esac
  fi
 else
@@ -2787,7 +2796,7 @@ if test "${enable_newlib_elix_level+set}
   2)   newlib_elix_level=2 ;;
   3)   newlib_elix_level=3 ;;
   4)   newlib_elix_level=4 ;;
-  *)   as_fn_error "bad value ${enableval} for newlib-elix-level option" "$LINENO" 5 ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-elix-level option" "$LINENO" 5  ;;
  esac
 else
   newlib_elix_level=0
@@ -2798,7 +2807,7 @@ if test "${enable_newlib_io_float+set}"
   enableval=$enable_newlib_io_float; case "${enableval}" in
   yes) newlib_io_float=yes ;;
   no)  newlib_io_float=no ;;
-  *)   as_fn_error "bad value ${enableval} for newlib-io-float option" "$LINENO" 5 ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-io-float option" "$LINENO" 5  ;;
  esac
 else
   newlib_io_float=yes
@@ -2809,7 +2818,7 @@ if test "${enable_newlib_supplied_syscal
   enableval=$enable_newlib_supplied_syscalls; case "${enableval}" in
   yes) newlib_may_supply_syscalls=yes ;;
   no)  newlib_may_supply_syscalls=no ;;
-  *)   as_fn_error "bad value ${enableval} for newlib-supplied-syscalls option" "$LINENO" 5 ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-supplied-syscalls option" "$LINENO" 5  ;;
  esac
 else
   newlib_may_supply_syscalls=yes
@@ -2846,7 +2855,7 @@ if test "`cd $srcdir && pwd`" != "`pwd`"
   am__isrc=' -I$(srcdir)'
   # test to see if srcdir already configured
   if test -f $srcdir/config.status; then
-    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
   fi
 fi
 
@@ -3126,7 +3135,7 @@ $as_echo "no" >&6; }
 fi
 
 
-  test -z "$CC" && as_fn_error "no acceptable cc found in \$PATH" "$LINENO" 5
+  test -z "$CC" && as_fn_error $? "no acceptable cc found in \$PATH" "$LINENO" 5
 fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using GNU C" >&5
@@ -3798,7 +3807,7 @@ esac
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_SED"; then
-    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
+    as_fn_error $? "no acceptable sed could be found in \$PATH" "$LINENO" 5
   fi
 else
   ac_cv_path_SED=$SED
@@ -4521,8 +4530,8 @@ fi
 
 test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "no acceptable C compiler found in \$PATH
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5 ; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
@@ -4636,9 +4645,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "C compiler cannot create executables
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5 ; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
@@ -4680,8 +4688,8 @@ done
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5 ; }
 fi
 rm -f conftest conftest$ac_cv_exeext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
@@ -4738,9 +4746,9 @@ $as_echo "$ac_try_echo"; } >&5
     else
 	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run C compiled programs.
+as_fn_error $? "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5 ; }
     fi
   fi
 fi
@@ -4791,8 +4799,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5 ; }
 fi
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
@@ -5190,7 +5198,7 @@ esac
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_GREP"; then
-    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_GREP=$GREP
@@ -5256,7 +5264,7 @@ esac
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_EGREP=$EGREP
@@ -5323,7 +5331,7 @@ esac
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_FGREP"; then
-    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    as_fn_error $? "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_FGREP=$FGREP
@@ -5439,7 +5447,7 @@ else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
-test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+test -z "$LD" && as_fn_error $? "no acceptable ld found in \$PATH" "$LINENO" 5
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
 $as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
 if test "${lt_cv_prog_gnu_ld+set}" = set; then :
@@ -7703,7 +7711,7 @@ else
   # Broken: fails on valid input.
 continue
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
@@ -7719,11 +7727,11 @@ else
 ac_preproc_ok=:
 break
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.i conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then :
   break
 fi
@@ -7762,7 +7770,7 @@ else
   # Broken: fails on valid input.
 continue
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
@@ -7778,18 +7786,18 @@ else
 ac_preproc_ok=:
 break
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.i conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then :
 
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5 ; }
 fi
 
 ac_ext=c
@@ -7918,8 +7926,7 @@ do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
 "
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11425,7 +11432,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11428 "configure"
+#line 11435 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11531,7 +11538,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11534 "configure"
+#line 11541 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11820,6 +11827,8 @@ subdirs="$subdirs a29khif"
  ;;
 	w65) subdirs="$subdirs w65"
  ;;
+	toaru) subdirs="$subdirs toaru"
+ ;;
 	z8ksim) subdirs="$subdirs z8ksim"
  ;;
   esac;
@@ -11961,6 +11970,7 @@ DEFS=`sed -n "$ac_script" confdefs.h`
 
 ac_libobjs=
 ac_ltlibobjs=
+U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
@@ -11976,7 +11986,7 @@ LTLIBOBJS=$ac_ltlibobjs
 
 
 if test -z "${MAY_SUPPLY_SYSCALLS_TRUE}" && test -z "${MAY_SUPPLY_SYSCALLS_FALSE}"; then
-  as_fn_error "conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
+  as_fn_error $? "conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
  if test -n "$EXEEXT"; then
@@ -11988,47 +11998,47 @@ else
 fi
 
 if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error "conditional \"AMDEP\" was never defined.
+  as_fn_error $? "conditional \"AMDEP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
-  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
+  as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_0_TRUE}" && test -z "${ELIX_LEVEL_0_FALSE}"; then
-  as_fn_error "conditional \"ELIX_LEVEL_0\" was never defined.
+  as_fn_error $? "conditional \"ELIX_LEVEL_0\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_1_TRUE}" && test -z "${ELIX_LEVEL_1_FALSE}"; then
-  as_fn_error "conditional \"ELIX_LEVEL_1\" was never defined.
+  as_fn_error $? "conditional \"ELIX_LEVEL_1\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_2_TRUE}" && test -z "${ELIX_LEVEL_2_FALSE}"; then
-  as_fn_error "conditional \"ELIX_LEVEL_2\" was never defined.
+  as_fn_error $? "conditional \"ELIX_LEVEL_2\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_3_TRUE}" && test -z "${ELIX_LEVEL_3_FALSE}"; then
-  as_fn_error "conditional \"ELIX_LEVEL_3\" was never defined.
+  as_fn_error $? "conditional \"ELIX_LEVEL_3\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_4_TRUE}" && test -z "${ELIX_LEVEL_4_FALSE}"; then
-  as_fn_error "conditional \"ELIX_LEVEL_4\" was never defined.
+  as_fn_error $? "conditional \"ELIX_LEVEL_4\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${USE_LIBTOOL_TRUE}" && test -z "${USE_LIBTOOL_FALSE}"; then
-  as_fn_error "conditional \"USE_LIBTOOL\" was never defined.
+  as_fn_error $? "conditional \"USE_LIBTOOL\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${HAVE_SYS_DIR_TRUE}" && test -z "${HAVE_SYS_DIR_FALSE}"; then
-  as_fn_error "conditional \"HAVE_SYS_DIR\" was never defined.
+  as_fn_error $? "conditional \"HAVE_SYS_DIR\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 
@@ -12178,19 +12188,19 @@ export LANGUAGE
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -12386,7 +12396,7 @@ $as_echo X"$as_dir" |
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -12440,7 +12450,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # values after options handling.
 ac_log="
 This file was extended by newlib $as_me 1.19.0, which was
-generated by GNU Autoconf 2.65.  Invocation command line was
+generated by GNU Autoconf 2.67.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -12497,10 +12507,10 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_writ
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 newlib config.status 1.19.0
-configured by $0, generated by GNU Autoconf 2.65,
+configured by $0, generated by GNU Autoconf 2.67,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2010 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -12518,11 +12528,16 @@ ac_need_defaults=:
 while test $# != 0
 do
   case $1 in
-  --*=*)
+  --*=?*)
     ac_option=`expr "X$1" : 'X\([^=]*\)='`
     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
     ac_shift=:
     ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
   *)
     ac_option=$1
     ac_optarg=$2
@@ -12544,6 +12559,7 @@ do
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
@@ -12554,7 +12570,7 @@ do
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) as_fn_error "unrecognized option: \`$1'
+  -*) as_fn_error $? "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
 
   *) as_fn_append ac_config_targets " $1"
@@ -12876,7 +12892,7 @@ do
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
 
-  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5 ;;
   esac
 done
 
@@ -12913,7 +12929,7 @@ $debug ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -12930,7 +12946,7 @@ if test "x$ac_cr" = x; then
 fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\r'
+  ac_cs_awk_cr='\\r'
 else
   ac_cs_awk_cr=$ac_cr
 fi
@@ -12944,18 +12960,18 @@ _ACEOF
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -13044,20 +13060,28 @@ if sed "s/$ac_cr//" < /dev/null > /dev/n
 else
   cat
 fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
 s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
 s/^[^=]*=[	 ]*$//
 }'
 fi
@@ -13075,7 +13099,7 @@ do
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5 ;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -13103,7 +13127,7 @@ do
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5 ;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
@@ -13130,7 +13154,7 @@ $as_echo "$as_me: creating $ac_file" >&6
 
     case $ac_tag in
     *:-:* | *:-) cat >"$tmp/stdin" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5  ;;
     esac
     ;;
   esac
@@ -13267,22 +13291,22 @@ s&@MKDIR_P@&$ac_MKDIR_P&;t t
 $ac_datarootdir_hack
 "
 eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
   { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
+which seems to be undefined.  Please make sure it is defined" >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
+which seems to be undefined.  Please make sure it is defined" >&2;}
 
   rm -f "$tmp/stdin"
   case $ac_file in
   -) cat "$tmp/out" && rm -f "$tmp/out";;
   *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
   esac \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
  ;;
 
 
@@ -14043,7 +14067,7 @@ _ACEOF
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -14064,7 +14088,7 @@ if test "$no_create" != yes; then
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit $?
+  $ac_cs_success || as_fn_exit 1
 fi
 
 #
@@ -14205,7 +14229,7 @@ $as_echo "$as_me: running $SHELL $ac_sub
       # The eval makes quoting arguments work.
       eval "\$SHELL \"\$ac_sub_configure\" $ac_sub_configure_args \
 	   --cache-file=\"\$ac_sub_cache_file\" --srcdir=\"\$ac_srcdir\"" ||
-	as_fn_error "$ac_sub_configure failed for $ac_dir" "$LINENO" 5
+	as_fn_error $? "$ac_sub_configure failed for $ac_dir" "$LINENO" 5
     fi
 
     cd "$ac_popdir"
diff -rupN _source/newlib-1.19.0/newlib/libc/sys/configure.in newlib-1.19.0/newlib/libc/sys/configure.in
--- _source/newlib-1.19.0/newlib/libc/sys/configure.in	2010-02-24 14:59:55.000000000 -0600
+++ newlib-1.19.0/newlib/libc/sys/configure.in	2011-04-24 20:37:33.000000000 -0500
@@ -45,6 +45,7 @@ if test -n "${sys_dir}"; then
 	sysvnecv70) AC_CONFIG_SUBDIRS(sysvnecv70) ;;
 	tic80) AC_CONFIG_SUBDIRS(tic80) ;;
 	w65) AC_CONFIG_SUBDIRS(w65) ;;
+	toaru) AC_CONFIG_SUBDIRS(toaru) ;;
 	z8ksim) AC_CONFIG_SUBDIRS(z8ksim) ;;
   esac;
 fi
